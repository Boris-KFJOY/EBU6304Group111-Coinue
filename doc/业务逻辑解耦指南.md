# Coinue 业务逻辑解耦指南

## 概述

本文档介绍了Coinue项目中业务逻辑与界面交互逻辑的解耦方案。通过将业务逻辑从控制器类中分离到Model层，实现了更好的代码结构和可维护性。

## 解耦架构

### 核心组件

1. **User类** (`src/main/java/com/coinue/model/User.java`)
   - 扩展了用户实体，添加了业务逻辑方法
   - 包含数据验证、用户会话管理等功能
   - 提供用户数据存储和加载的接口

2. **UserDataService类** (`src/main/java/com/coinue/model/UserDataService.java`)
   - 负责用户个人数据的存储和管理
   - 为每个用户创建独立的数据目录
   - 支持分析数据、预算数据、支出数据等多种数据类型

3. **UserDataManager类** (`src/main/java/com/coinue/util/UserDataManager.java`)
   - 管理全局用户信息（用户账户数据）
   - 处理用户注册、登录、密码重置等操作

## 数据存储结构

```
data/
├── users.json                    # 全局用户账户信息
└── users/                        # 用户个人数据目录
    ├── {username}/               # 每个用户的独立目录
    │   ├── analysis_data.json    # 分析数据
    │   ├── budget_data.json      # 预算数据
    │   ├── expense_data.json     # 支出数据
    │   ├── user_settings.json    # 用户设置
    │   └── transaction_history.json # 交易历史
    └── ...
```

## 解耦完成情况

### SignUpController.java ✅ 已完成

```java
✅ 将输入验证逻辑解耦到User类的静态方法中 - 使用User.validateRegistrationData()
✅ 将密码匹配验证逻辑解耦到User类的静态方法中 - 集成在validateRegistrationData()中
✅ 将用户注册业务逻辑解耦到User类的静态方法中 - 使用user.register()
✅ 将用户数据保存逻辑解耦到User类的实例方法中 - 集成在register()方法中
```

### RegisterController.java ✅ 已完成

```java
✅ 将登录输入验证逻辑解耦到User类的静态方法中 - 集成在User.login()中
✅ 将用户身份验证逻辑解耦到User类的静态方法中 - 使用User.login()
✅ 将用户会话管理逻辑解耦到User类或专门的会话管理类中 - 集成在User.login()中
```

### ForgetController.java ✅ 已完成

```java
✅ 将用户查找逻辑解耦到User类的静态方法中 - 使用User.findByUsernameOrEmail()
✅ 将密码重置输入验证逻辑解耦到User类的静态方法中 - 使用User.validatePasswordResetData()
✅ 将密码匹配验证逻辑解耦到User类的静态方法中 - 集成在validatePasswordResetData()中
✅ 将身份验证逻辑解耦到User类的实例方法中 - 使用user.validateIdentity()
✅ 将密码重置业务逻辑解耦到User类的实例方法中 - 使用user.resetPassword()
```

## 实际解耦效果展示

### 用户注册解耦效果

**解耦前的代码 (SignUpController.java):**
```java
// 获取用户输入
String username = signUpUsernameField.getText();
String email = emailField.getText();
String password = signUpPasswordField.getText();
String confirmPassword = confirmPasswordField.getText();
LocalDate birthday = birthdayPicker.getValue();
String securityQuestion = securityQuestionComboBox.getValue();
String securityAnswer = securityAnswerField.getText();

// 验证用户输入 - 大量重复的验证逻辑
if (username.isEmpty() || email.isEmpty() || password.isEmpty() || confirmPassword.isEmpty() ||
    birthday == null || securityQuestion == null || securityQuestion.isEmpty() || securityAnswer.isEmpty()) {
    showAlert(Alert.AlertType.ERROR, "输入错误", "所有字段都必须填写");
    return;
}

// 验证密码匹配
if (!password.equals(confirmPassword)) {
    showAlert(Alert.AlertType.ERROR, "密码错误", "两次输入的密码不匹配");
    return;
}

// 创建用户对象
User user = new User(username, email, password, securityQuestion, securityAnswer, birthday);

// 保存用户数据 - 直接调用UserDataManager
boolean success = com.coinue.util.UserDataManager.getInstance().createUser(user);
```

**解耦后的代码 (SignUpController.java):**
```java
// 获取用户输入
String username = signUpUsernameField.getText();
String email = emailField.getText();
String password = signUpPasswordField.getText();
String confirmPassword = confirmPasswordField.getText();
LocalDate birthday = birthdayPicker.getValue();
String securityQuestion = securityQuestionComboBox.getValue();
String securityAnswer = securityAnswerField.getText();

// 使用User类的静态方法进行数据验证 - 简洁且可复用
String validationResult = User.validateRegistrationData(username, email, password, 
                                                       confirmPassword, securityQuestion, 
                                                       securityAnswer, birthday);
if (validationResult != null) {
    showAlert(Alert.AlertType.ERROR, "输入错误", validationResult);
    return;
}

// 创建用户对象并注册 - 封装了复杂的注册逻辑
User user = new User(username, email, password, securityQuestion, securityAnswer, birthday);
boolean success = user.register(); // 使用User实例方法进行注册
```

### 用户登录解耦效果

**解耦前的代码 (RegisterController.java):**
```java
String usernameOrEmail = usernameField.getText();
String password = passwordField.getText();

// 验证输入 - 重复的验证逻辑
if (usernameOrEmail.isEmpty() || password.isEmpty()) {
    showAlert(Alert.AlertType.ERROR, "登录错误", "用户名/邮箱和密码不能为空");
    return;
}

// 验证用户登录 - 直接调用UserDataManager
User user = com.coinue.util.UserDataManager.getInstance().validateLogin(usernameOrEmail, password);

if (user == null) {
    showAlert(Alert.AlertType.ERROR, "登录失败", "用户名/邮箱或密码不正确");
    return;
}

// 手动管理登录成功逻辑
System.out.println("用户登录成功: " + usernameOrEmail);
```

**解耦后的代码 (RegisterController.java):**
```java
String usernameOrEmail = usernameField.getText();
String password = passwordField.getText();

// 使用User类的静态方法进行登录（包含输入验证和身份验证）- 一行代码完成所有验证
User user = User.login(usernameOrEmail, password);

if (user == null) {
    showAlert(Alert.AlertType.ERROR, "登录失败", "用户名/邮箱或密码不正确，请重试");
    return;
}

// 登录成功，用户会话已由User.login()自动管理
System.out.println("用户登录成功: " + user.getUsername());
```

### 密码重置解耦效果

**解耦前的代码 (ForgetController.java):**
```java
// 大量手动验证逻辑
if (usernameOrEmail.isEmpty() || birthday == null || securityAnswer.isEmpty() 
        || newPassword.isEmpty() || confirmPassword.isEmpty()) {
    showAlert(Alert.AlertType.ERROR, "输入错误", "所有字段都必须填写");
    return;
}

if (!newPassword.equals(confirmPassword)) {
    showAlert(Alert.AlertType.ERROR, "密码错误", "两次输入的密码不一致");
    return;
}

// 手动验证身份
if (!user.getBirthday().equals(birthday)) {
    showAlert(Alert.AlertType.ERROR, "验证失败", "生日信息不匹配");
    return;
}

// 直接调用UserDataManager
boolean success = com.coinue.util.UserDataManager.getInstance().resetPassword(
        usernameOrEmail, securityAnswer, newPassword);
```

**解耦后的代码 (ForgetController.java):**
```java
// 使用User类的静态方法进行输入验证 - 一行代码完成所有验证
String validationResult = User.validatePasswordResetData(usernameOrEmail, newPassword, 
                                                        confirmPassword, securityAnswer, birthday);
if (validationResult != null) {
    showAlert(Alert.AlertType.ERROR, "输入错误", validationResult);
    return;
}

// 使用User类的实例方法进行身份验证 - 封装了复杂的验证逻辑
if (!user.validateIdentity(birthday, securityAnswer)) {
    showAlert(Alert.AlertType.ERROR, "验证失败", "生日或安全问题答案不正确");
    return;
}

// 使用User类的实例方法重置密码 - 封装了密码重置和保存逻辑
boolean success = user.resetPassword(newPassword);
```

## 解耦实现示例

**原代码 (控制器中):**
```java
// 验证用户输入
if (username.isEmpty() || email.isEmpty() || password.isEmpty() || confirmPassword.isEmpty() ||
    birthday == null || securityQuestion == null || securityQuestion.isEmpty() || securityAnswer.isEmpty()) {
    showAlert(Alert.AlertType.ERROR, "输入错误", "所有字段都必须填写");
    return;
}

// 验证密码匹配
if (!password.equals(confirmPassword)) {
    showAlert(Alert.AlertType.ERROR, "密码错误", "两次输入的密码不匹配");
    return;
}

// 创建用户对象
User user = new User(username, email, password, securityQuestion, securityAnswer, birthday);

// 保存用户数据
boolean success = com.coinue.util.UserDataManager.getInstance().createUser(user);
```

**解耦后的代码:**
```java
// 使用User类的静态方法进行验证
String validationResult = User.validateRegistrationData(username, email, password, confirmPassword, 
                                                       securityQuestion, securityAnswer, birthday);
if (validationResult != null) {
    showAlert(Alert.AlertType.ERROR, "输入错误", validationResult);
    return;
}

// 创建用户对象并直接注册
User user = new User(username, email, password, securityQuestion, securityAnswer, birthday);
boolean success = user.register(); // 使用User实例方法
```

### 用户登录解耦示例

**原代码 (控制器中):**
```java
// 验证输入
if (usernameOrEmail.isEmpty() || password.isEmpty()) {
    showAlert(Alert.AlertType.ERROR, "登录错误", "用户名/邮箱和密码不能为空");
    return;
}

// 验证用户登录
User user = com.coinue.util.UserDataManager.getInstance().validateLogin(usernameOrEmail, password);

if (user == null) {
    showAlert(Alert.AlertType.ERROR, "登录失败", "用户名/邮箱或密码不正确");
    return;
}
```

**解耦后的代码:**
```java
// 使用User类的静态方法进行登录
User user = User.login(usernameOrEmail, password);

if (user == null) {
    showAlert(Alert.AlertType.ERROR, "登录失败", "用户名/邮箱或密码不正确，请重试");
    return;
}

// 用户已自动设置为当前登录用户
// User.getCurrentUser() 可以获取当前登录的用户
```

### 密码重置解耦示例

**原代码 (控制器中):**
```java
// 验证输入
if (usernameOrEmail.isEmpty() || birthday == null || securityAnswer.isEmpty() 
        || newPassword.isEmpty() || confirmPassword.isEmpty()) {
    showAlert(Alert.AlertType.ERROR, "输入错误", "所有字段都必须填写");
    return;
}

// 验证两次密码输入是否一致
if (!newPassword.equals(confirmPassword)) {
    showAlert(Alert.AlertType.ERROR, "密码错误", "两次输入的密码不一致");
    return;
}

// 验证生日
if (!user.getBirthday().equals(birthday)) {
    showAlert(Alert.AlertType.ERROR, "验证失败", "生日信息不匹配");
    return;
}

// 重置密码
boolean success = com.coinue.util.UserDataManager.getInstance().resetPassword(
        usernameOrEmail, securityAnswer, newPassword);
```

**解耦后的代码:**
```java
// 使用User类的静态方法进行验证
String validationResult = User.validatePasswordResetData(usernameOrEmail, newPassword, 
                                                        confirmPassword, securityAnswer, birthday);
if (validationResult != null) {
    showAlert(Alert.AlertType.ERROR, "输入错误", validationResult);
    return;
}

// 查找用户并验证身份
User user = User.findByUsernameOrEmail(usernameOrEmail);
if (user == null || !user.validateIdentity(birthday, securityAnswer)) {
    showAlert(Alert.AlertType.ERROR, "验证失败", "用户信息或身份验证失败");
    return;
}

// 重置密码
boolean success = user.resetPassword(newPassword);
```

## 用户数据管理

### 保存和加载用户个人数据

```java
// 获取当前登录用户
User currentUser = User.getCurrentUser();

// 保存分析数据
Map<String, Object> analysisData = new HashMap<>();
analysisData.put("lastAnalysisDate", LocalDate.now());
analysisData.put("totalExpenses", 1500.0);
currentUser.saveAnalysisData(analysisData);

// 加载分析数据
Map<String, Object> loadedData = currentUser.loadAnalysisData(Map.class);

// 保存预算数据
BudgetData budget = new BudgetData();
budget.setMonthlyLimit(2000.0);
currentUser.saveBudgetData(budget);

// 加载预算数据
BudgetData loadedBudget = currentUser.loadBudgetData(BudgetData.class);

// 保存自定义数据
List<String> tags = Arrays.asList("食物", "交通", "娱乐");
currentUser.saveCustomData("expense_tags.json", tags);

// 加载自定义数据
List<String> loadedTags = currentUser.loadCustomData("expense_tags.json", List.class);
```

## 会话管理

```java
// 登录用户
User user = User.login("username", "password");

// 检查是否有用户登录
if (User.isLoggedIn()) {
    User currentUser = User.getCurrentUser();
    System.out.println("当前登录用户: " + currentUser.getUsername());
}

// 用户注销
User.logout();
```

## 优势

1. **代码复用**: 业务逻辑可以在不同的控制器中复用
2. **可测试性**: 业务逻辑独立于UI，更容易进行单元测试
3. **可维护性**: 修改业务逻辑时不需要修改多个控制器
4. **数据隔离**: 每个用户拥有独立的数据存储空间
5. **扩展性**: 容易添加新的业务逻辑和数据类型

## 注意事项

1. **JSON序列化**: 确保要保存的数据对象可以被Jackson正确序列化
2. **文件权限**: 确保应用有权限在data目录下创建和修改文件
3. **数据备份**: 重要数据应该定期备份
4. **并发安全**: 在多线程环境下使用时要注意线程安全

## 解耦效果总结

通过本次解耦，我们实现了以下改进：

1. **代码行数减少**: 每个控制器的业务逻辑代码减少了约50-70%
2. **代码复用性提升**: 验证逻辑可以在多个控制器中重复使用
3. **错误处理统一**: 所有验证错误都有统一的错误消息格式
4. **可测试性增强**: 业务逻辑与UI分离，更容易进行单元测试
5. **维护性提升**: 修改业务规则只需要修改User类，不需要修改多个控制器

## 下一步计划

1. ✅ 完成TODO标记的业务逻辑解耦 - **已完成**
2. 🚀 将Analysis页面与用户数据关联 - **进行中**
3. 🔄 实现用户数据的自动加载和显示
4. 🛡️ 添加数据同步和备份功能
5. 🧪 为业务逻辑方法添加单元测试 